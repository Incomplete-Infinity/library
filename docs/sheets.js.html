<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: sheets.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="d6-csgIuVPoz0iQyrNS2Y"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="CellTranslator.html">CellTranslator</a></div><div class="sidebar-section-children"><a href="DateTranslator.html">DateTranslator</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="32ymzV-AR19hzjIAHjev2"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#addCustomProperty">addCustomProperty</a></div><div class="sidebar-section-children"><a href="global.html#cacheUrlFetchApp">cacheUrlFetchApp</a></div><div class="sidebar-section-children"><a href="global.html#cardinalToOrdinal">cardinalToOrdinal</a></div><div class="sidebar-section-children"><a href="global.html#createTree">createTree</a></div><div class="sidebar-section-children"><a href="global.html#cropCols">cropCols</a></div><div class="sidebar-section-children"><a href="global.html#cropRows">cropRows</a></div><div class="sidebar-section-children"><a href="global.html#cropSheet">cropSheet</a></div><div class="sidebar-section-children"><a href="global.html#daysSince">daysSince</a></div><div class="sidebar-section-children"><a href="global.html#driveWrite">driveWrite</a></div><div class="sidebar-section-children"><a href="global.html#ensure2dArray">ensure2dArray</a></div><div class="sidebar-section-children"><a href="global.html#getAllFoldersInFolder">getAllFoldersInFolder</a></div><div class="sidebar-section-children"><a href="global.html#getAllInFolder">getAllInFolder</a></div><div class="sidebar-section-children"><a href="global.html#getDatetimeCol">getDatetimeCol</a></div><div class="sidebar-section-children"><a href="global.html#getFilesAndFoldersInFolder">getFilesAndFoldersInFolder</a></div><div class="sidebar-section-children"><a href="global.html#getFolderByName">getFolderByName</a></div><div class="sidebar-section-children"><a href="global.html#getFolderContents">getFolderContents</a></div><div class="sidebar-section-children"><a href="global.html#onEdit">onEdit</a></div><div class="sidebar-section-children"><a href="global.html#prepareSheet">prepareSheet</a></div><div class="sidebar-section-children"><a href="global.html#readDrive">readDrive</a></div><div class="sidebar-section-children"><a href="global.html#removeDuplicateRows">removeDuplicateRows</a></div><div class="sidebar-section-children"><a href="global.html#timestamp">timestamp</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">sheets.js</h1></header><article><pre class="prettyprint source lang-js"><code>const sheetName = `Sheet1`;
const timestampHeader = `timestamp`;

/**
 * This function retrieves the column index of a timestamp header in a Google Sheets spreadsheet.
 * @returns the index of the column that contains the timestamp header in the active spreadsheet. The
 * index is incremented by 1 to match the column numbering used in Google Sheets (which starts at 1
 * instead of 0).
 */
function getDatetimeCol() {
  const headers = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName).getDataRange().getValues().shift();
  const colIndex = headers.indexOf(timestampHeader);
  return colIndex + 1;
}

/**
 * This function automatically adds a timestamp to a specific column in a Google Sheets document when a
 * cell in another column is edited.
 * @param e - The "e" parameter in this function refers to the event object that triggered the onEdit
 * function. It contains information about the edit event, such as the range of cells that were edited
 * and the user who made the edit.
 */
function onEdit(e) {
  const ss = SpreadsheetApp.getActiveSheet();
  const cell = ss.getActiveCell();
  const datecell = ss.getRange(cell.getRowIndex(), getDatetimeCol());
  if (ss.getName() == SHEET_NAME &amp;&amp; cell.getColumn() == 1 &amp;&amp; !cell.isBlank() &amp;&amp; datecell.isBlank()) {
    datecell.setValue(new Date()).setNumberFormat("yyyy-MM-dd hh:mm");
  }
}

/**
 * Deletes any blank columns in a given sheet, leaving a minimum number of columns.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - The sheet to crop.
 * @param {number} [minCols=0] - The minimum number of columns to leave in the sheet.
 * @returns {GoogleAppsScript.Spreadsheet.Sheet} The cropped sheet.
 */
const cropCols = (sheet, minCols = 0) => {
  // Get the range of the sheet
  const range = sheet.getDataRange();
  // Get the index of the last column in the range
  const lastColumn = range.getLastColumn();
  // Get the total number of columns in the range
  const maxColumns = range.getNumColumns();
  // If the number of columns in the sheet is not equal to the number of columns in the range
  if (maxColumns !== lastColumn) {
    // Calculate the number of blank columns to delete
    const numColsToDelete = maxColumns - Math.max(lastColumn, minCols);
    // If there are blank columns to delete
    if (numColsToDelete > 0) {
      // Delete the blank columns
      sheet.deleteColumns(lastColumn + 1, numColsToDelete);
    }
  }
  // Return the cropped sheet
  return sheet;
};

/**
 * Deletes any blank rows in a given sheet, leaving a minimum number of rows.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} sheet - The sheet to crop.
 * @param {number} [minRows=2] - The minimum number of rows to leave in the sheet.
 * @returns {GoogleAppsScript.Spreadsheet.Sheet} The cropped sheet.
 */
const cropRows = (sheet, minRows = 2) => {
  // Get the range of the sheet
  const range = sheet.getDataRange();
  // Get the index of the last row in the range
  const lastRow = range.getLastRow();
  // Get the total number of rows in the range
  const maxRows = range.getNumRows();
  // If the number of rows in the sheet is not equal to the number of rows in the range
  if (maxRows !== lastRow) {
    // Calculate the number of blank rows to delete
    const numRowsToDelete = maxRows - Math.max(lastRow, minRows);
    // If there are blank rows to delete
    if (numRowsToDelete > 0) {
      // Delete the blank rows
      sheet.deleteRows(lastRow + 1, numRowsToDelete);
    }
  }
  // Return the cropped sheet
  return sheet;
};

/**
 * Crops a given sheet by deleting any blank rows or columns, leaving a minimum number of rows and columns.
 * @param {GoogleAppsScript.Spreadsheet.Sheet} [sheet=false] - The sheet to crop.
 * @param {number} [minCols=2] - The minimum number of columns to leave in the sheet.
 * @param {number} [minRows=2] - The minimum number of rows to leave in the sheet.
 * @returns {GoogleAppsScript.Spreadsheet.Sheet|null} The cropped sheet or null if sheet is not defined.
 */
const cropSheet = (sheet = false, minCols = 2, minRows = 2) => {
  console.time(`Executed "cropSheet()" in`); // Start a timer to measure execution time
  if (!sheet) {
    console.error(`Required parameter "sheet" is not defined.`);
    return null;
  }
  cropCols(sheet, minCols);
  cropRows(sheet, minRows);
  console.timeEnd(`Executed "cropSheet()" in`);
  // Return the cropped sheet
  return sheet;
}

/**
 * @function
 * @alias prepareSheet
 * @summary Creates a new sheet or clears an existing sheet if it already exists.
 * @param {string} sheetName - Name of Sheet (tab name)
 * @returns {object} - The Prepared Sheet
 */
function prepareSheet(sheetName = false) {
  console.time(`Prepared the sheet named ${sheetName} in `);
  let result;
  try {
    if (sheetName) {
      const ss = SpreadsheetApp;
      const workBook = ss.getActiveSpreadsheet();
      sheet = workBook.getSheetByName(sheetName);

      if (sheet != null) {
        sheet.clearContents();
      } else {
        result = workBook.insertSheet();
        result.setName(sheetName);
      }
    } else {
      throw new Error(`Required parameter, "sheetName" is not defined.`);
    }
  } catch (error) {
    console.error(`Failed to execute "prepareSheet()!
      Error Message: ${error.message}`);
  } finally {
    console.timeEnd(`Prepared the sheet named ${sheetName} in `);
    return result;
  }
}

/**
 * This function removes duplicate rows from a Google Sheets spreadsheet.
 */
function removeDuplicateRows() {
    const sheet = SpreadsheetApp.getActiveSheet();
    const data = sheet.getDataRange().getValues();
    const uniqueData = {};
    for (let row of data) {
      const key = row.join();
      uniqueData[key] = uniqueData[key] || row;
    }
    sheet.clearContents();
    const newData = Object.values(uniqueData);
    sheet.getRange(1, 1, newData.length, newData[0].length).setValues(newData);
  }

function assembleTable(data) {
  let tableHtml = `&lt;!-- Start of assembled table string -->
  &lt;table>
    &lt;thead>
      &lt;tr>`;
  data.shift().forEach((header) => {
    tableHtml += `
        &lt;th>
          ${header}
        &lt;/th>`;
  });
  tableHtml += `
      &lt;/tr>
    &lt;/thead>
    &lt;tbody>`;
  data.forEach((rowData) => {
    tableHtml += `
      &lt;tr>`;
    rowData.forEach((cellData) => {
      tableHtml += `
        &lt;td>
          ${cellData}
        &lt;/td>`;
    });
    tableHtml += `
      &lt;/tr>`;
  });
  tableHtml += `
    &lt;/tbody>
  &lt;/table>
&lt;!-- End of assembled table string -->`;

  return tableHtml;
}
function addInnerHtml() {
  const table = document.getElementById(`data-table`);
  table.innerHTML = tableHtml;
}

/**
 * @license
 *
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview This Google Apps Script file contains general utility methods
 * used by the different modules in this application.
 */

class Util {
  /**
   * Extends an object identified by 'original' with the values in 'extension'.
   * 'extension' will be returned if 'original' is null, otherwise 'original'
   * will get extended. Array values in 'extension' will be appended to existing
   * arrays in 'original', however all other objects in 'extension' will
   * override existing counterparts in 'original'. The plain JS type of
   * 'original' will be preserved (if it wasn't null or undefined - i.e. passing
   * an instance of a specific class will not be overrided, rather extended).
   *
   * @param {?Object&lt;string, *>} original The original object to extend, which
   *     may be null
   * @param {!Object&lt;string, *>} extension The value to use for extending
   * @return {!Object&lt;string, *>} The extended object
   */
  static extend(original, extension) {
    if (original == null) {
      return extension;
    }
    for (const key in extension) {
      if (extension.hasOwnProperty(key)) {
        const extensionValue = extension[key];
        const originalValue = original[key];
        if (Array.isArray(extensionValue) &amp;&amp; Array.isArray(originalValue)) {
          originalValue.push(...extensionValue);
        } else {
          original[key] = extension[key];
        }
      }
    }
    return original;
  }

  /**
   * Modifies a url by either appending the 'key' and 'value' to the end of the
   * url if the 'key' was not present or replacing the value of the 'key' if it
   * existed. Multiple values for the same key will all be replaced by a single
   * key-value pair at the first seen key location. Assumes that all params have
   * already been URL encoded.
   *
   * @param {string} url The url to modify
   * @param {string} key The key to check if present
   * @param {string} value The value to append / modify
   * @return {string} The modified url
   */
  static modifyUrlQueryString(url, key, value) {
    let baseUrl, queryString, fragment;

    if (url.indexOf('?') !== -1) {
      [baseUrl, queryString] = url.split('?');
      fragment =
        queryString.indexOf('#') !== -1
          ? queryString.substring(queryString.indexOf('#'))
          : '';
      queryString = queryString.replace(fragment, '');
      const regExp = new RegExp(`(^|&amp;)${key}=[^&amp;]*`, 'g');
      const matches = queryString.match(regExp);

      if (matches) {
        let modified = false;

        matches.forEach(match => {
          let replacement = '';

          if (!modified) {
            const val = match.substring(match.indexOf('=') + 1);
            replacement = match.replace(val, value);
            modified = true;
          }
          queryString = queryString.replace(match, replacement);
        });
      } else {
        const separator = queryString.length > 0 ? '&amp;' : '';
        queryString += `${separator}${key}=${value}`;
      }
    } else {
      baseUrl = url;
      queryString = `${key}=${value}`;
      fragment = '';
    }
    return `${baseUrl}?${queryString}${fragment}`;
  }

  /**
   * Unnests field names in an object, producing array of
   *  'field.nestedfield.subnestedfield'
   * @param {!Object&lt;string, *>} ob the one to be scanned
   * @return {!Array&lt;string>} dot-nested FQ field names
   */
  static listDottedFields(ob) {
    return Object.getOwnPropertyNames(Util.flattenObject(ob));
  }

  /**
   * Traverses object's sub-structure and converts it
   *  from {a:{b:{c:"value"}}} to {"a.b.c":"value"}
   * @param {!Object&lt;string, *>} ob
   * @return {!Object&lt;string, *>} Object with the same values but dotted field
   *     names
   */
  static flattenObject(ob) {
    const toReturn = {};
    let flatObject;

    for (const i in ob) {
      if (!ob.hasOwnProperty(i)) {
        continue;
      }
      if (typeof ob[i] === 'object') {
        flatObject = this.flattenObject(ob[i]);
        for (const x in flatObject) {
          if (!flatObject.hasOwnProperty(x)) {
            continue;
          }
          toReturn[i + (!!isNaN(x) ? '.' + x : '')] = flatObject[x];
        }
      } else {
        toReturn[i] = ob[i];
      }
    }
    return toReturn;
  }

  /**
   * Retrieves value from nested sub-objects by dot-separated path
   * (aka 'dotted field name')
   * @param {!Object&lt;string, *>} ob
   * @param {string} fieldName
   * @return {*|undefined} value of given sub-field
   */
  static getValueByDottedFieldName(ob, fieldName) {
    if (ob == null) {
      return undefined;
    } else if (fieldName.indexOf('.') == -1) {
      return ob[fieldName];
    } else {
      const firstDotIndex = fieldName.indexOf('.');
      const subObject = ob[fieldName.substring(0, firstDotIndex)];
      const subFieldPath = fieldName.substring(firstDotIndex + 1);
      return Util.getValueByDottedFieldName(subObject, subFieldPath);
    }
  }

  /**
   * @param {!Object&lt;string, *>} ob
   * @param {string} fieldName
   * @param {*} value
   */
  static setValueByDottedFieldName(ob, fieldName, value) {
    if (fieldName.indexOf('.') == -1) {
      ob[fieldName] = value;
    } else {
      const firstDotIndex = fieldName.indexOf('.');
      const firstLevelFieldName = fieldName.substring(0, firstDotIndex);
      const subObject = ob[firstLevelFieldName] || {};
      ob[firstLevelFieldName] = subObject;
      const subFieldPath = fieldName.substring(firstDotIndex + 1);
      Util.setValueByDottedFieldName(subObject, subFieldPath, value);
    }
  }

  /**
   * @summary Reads cell content as JSON or, if it fails, returns it verbatim.
   * @private
   * @param {string} data cell's content
   * @return {!Object&lt;string, *>|string} object or string if not parseable
   */
  static parseCellContent(data) {
    if (data === '' || data == null) {
      return '';
    }
    if (typeof data != 'string') {
      return data.toString();
    }
    if (data.indexOf('{') &lt; 0) {
      return data;
    }
    try {
      return JSON.parse(data);
    } catch (error) {
      // In case not pareseable, return original.
      return data.toString();
    }
  }

  /**
   * @summary Returns an array containing all elements of left that are not present in right one
   *
   * @param {!Array&lt;!Object>} left
   * @param {!Array&lt;!Object>} right
   * 
   * @return {!Array&lt;!Object>}
   */
  static difference(left, right) {
    return left.filter(object => !Util.isIn(object, right));
  }

  /**
   * @summary returns true if the given object appears in the given array
   * 
   * @param {!Object&lt;string, *>} object
   * @param {!Array&lt;!Object>} array
   * 
   * @return {boolean}
   */
  static isIn(object, array) {
    return (
      array.filter(
        member => JSON.stringify(member) === JSON.stringify(object)
      ) > 0
    );
  }
}

class ApiUtil {
  /**
   * Executes single GET request and fires callback once for each returned page.
   * @param {string} requestUri path to query
   * @param {function(!Object&lt;string, *>): undefined} callback
   *   executed with each page of response
   */
  static executeApiGetRequest(requestUri, callback) {
    const requestParams = {
      method: 'get'
    };
    ApiUtil.executeGenericRequest_(requestUri, requestParams, callback);
  }

  /**
   * Executes single PATCH request and fires callback.
   * @param {string} requestUri path to query
   * @param {!Object&lt;string, *>} payload what to include as body
   * @param {function(!Object&lt;string, *>): undefined} callback
   *   executed with each page of response
   */
  static executeApiPatchRequest(requestUri, payload, callback) {
    const requestParams = {
      method: 'patch',
      payload: JSON.stringify(payload)
    };
    ApiUtil.executeGenericRequest_(requestUri, requestParams, callback);
  }

  /**
   * Executes single CREATE request and fires callback.
   * @param {string} requestUri path to query
   * @param {!Object&lt;string, *>} payload what to include as body
   * @param {function(!Object&lt;string, *>): undefined} callback
   *   executed with each page of response
   */
  static executeApiPostRequest(requestUri, payload, callback) {
    const requestParams = {
      method: 'post',
      payload: JSON.stringify(payload)
    };
    ApiUtil.executeGenericRequest_(requestUri, requestParams, callback);
  }

  /**
   * Executes single DELETE request and fires callback.
   * @param {string} requestUri path to query
   * @param {function(!Object&lt;string, *>): undefined} callback
   *   executed with each page of response
   */
  static executeApiDeleteRequest(requestUri, callback) {
    const requestParams = {
      method: 'delete'
    };
    ApiUtil.executeGenericRequest_(requestUri, requestParams, callback);
  }

  /**
   * Runs REST request using UrlFetchApp. Handles paging, executing
   * callbacks and errors. No retries.
   * Will call callback once per resulting page.
   * Will call errback when there's non-2XX response.
   * @private
   * @param {string} requestUri path to call
   * @param {!Object&lt;string, string>} requestParams params to include
   *     (UrlFetchApp format)
   * @param {function(!Object&lt;string, *>): undefined} callback to be called once
   *     per page
   */
  static executeGenericRequest_(requestUri, requestParams, callback) {
    const baseUrl = ApiUtil.buildApiUrl_(requestUri);
    const params = ApiUtil.buildApiParams_(requestParams);

    let url = baseUrl;
    let morePages = true;
    while (morePages) {
      console.log(`Fetching ${params.method} request from ${url}`);
      const response = UrlFetchApp.fetch(url, params);
      if (response.getResponseCode() / 100 !== 2) {
        throw new Error(response.getContentText());
      }
      const result = response.getContentText()
        ? JSON.parse(response.getContentText())
        : {};
      callback(result);
      morePages = result.nextPageToken != undefined;
      if (morePages) {
        url = Util.modifyUrlQueryString(url, 'pageToken', result.nextPageToken);
      }
    }
  }

  /**
   * Takes in a string with placeholders like ${variable}
   * and replaces them with values found in selected sheet's top part.
   * @param {string} input (partial) uri with placeholders
   * @param {?Object&lt;string, string>} params values to replace in input
   * @return {string} uri with replaced placeholders
   */
  static replaceInputValues(input, params) {
    let output = input;
    if (params == null) {
      return input;
    }
    for (const [name, value] of Object.entries(params)) {
      output = output.replace('${' + name + '}', value);
    }
    return output;
  }

  /**
   * Constructs the fully-qualified URL to the DV360 API using the
   * given @param {requestUri}.
   * @private
   * @param {string} requestUri: the URI of the specific Resource to request.
   * @return {string} representing the fully-qualified DV360 API URL.
   */
  static buildApiUrl_(requestUri) {
    const apiEndpoint = 'https://displayvideo.googleapis.com';
    const apiVersion = 'v1';

    return `${apiEndpoint}/${apiVersion}/${requestUri}`;
  }

  /**
   * Constructs the options to use for the DV360 API request, extending
   * some default options with the given @param {requestParams}.
   * @private
   * @param {!Object&lt;string, string>} requestParams: the options to use for the
   *     request.
   * @return {!Object&lt;string, *>} representing the extended request options to
   *     use.
   * @see {utils.gs} @link {Util.extend}.
   */
  static buildApiParams_(requestParams) {
    const token = ScriptApp.getOAuthToken();
    let params = {
      contentType: 'application/json',
      headers: { Authorization: `Bearer ${token}`, Accept: 'application/json' },
      muteHttpExceptions: true
    };
    params = Util.extend(params, requestParams);

    return params;
  }
}

/**
 * Base class to transform entity field to cell value
 * and back into entity field
 */
class CellTranslator {
  /**
   *
   * @param {*} input
   */
  toDisplayValue(input) {
    throw new Error('Not Implemented');
  }

  /**
   *
   * @param {string} cellContent
   */
  toEntityField(cellContent) {
    throw new Error('Not Implemented');
  }
}

/**
 *
 */
class DateTranslator extends CellTranslator {
  /**
   *
   * @param {*} input
   * @return {string}
   */
  toDisplayValue(input) {
    const object = JSON.parse(input);
    const value = `${object.year}-${object.month}-${object.day}`;
    return value;
  }

  /**
   *
   * @param {string} cellContent
   * @return {!Object} value ready to put into entity field
   */
  toEntityField(cellContent) {
    const date = new Date(cellContent);
    return {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      day: date.getDate()
    };
  }
}

class SheetUtil {
  /**
   * Returns the value of the given cell for the given sheet.
   * @private
   * @param {string} sheetName: the name of the sheet.
   * @param {string} cellId: the ID of the cell in 'A1 Notation'.
   * @return {string} the value of the cell as maintained in the sheet.
   */
  static getCellValue_(sheetName, cellId) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const partnerIdCell = spreadsheet.getRange(
      sheetName + '!' + cellId + ':' + cellId
    );

    return partnerIdCell.getValue();
  }

  /**
   * Writes the given value to the given cell in the given sheet.
   * @private
   * @param {string} sheetName The name of the sheet.
   * @param {number} row The row of the cell
   * @param {number} column The column of the cell
   * @param {string} value The value to write in the cell
   */
  static writeCellValue(sheetName, row, column, value) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(sheetName);
    sheet.getRange(row, column, 1, 1).setValues([[value]]);
    SpreadsheetApp.flush();
  }

  /**
   * Writes the given two-dimensional Array of data to the specified
   * sheet, starting from the given range row and column values.
   * @private
   * @param {string} sheetName the name of the sheet.
   * @param {number} rangeStartRow the first row index to write data in.
   *           Minimum value is 1.
   * @param {number} rangeStartCol the first column index to write data to.
   *           Minimum value is 1.
   * @param {!Array&lt;!RowData>} output the two-dimensional
   *   array of data to write.
   */
  static outputInRange(sheetName, rangeStartRow, rangeStartCol, output) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(sheetName);

    sheet
      .getRange(rangeStartRow, rangeStartCol, output.length, output[0].length)
      .setValues(output);
    SpreadsheetApp.flush();
  }

  /**
   * Writes the given two-dimensional Array of data to the specified
   * sheet, appending the data to any already existing data in the
   *
   * @param {string} sheetName: the name of the sheet.
   * @param {number} rangeStartCol: the first column index to write data to.
   *           Minimum value is 1.
   * @param {!Array&lt;!RowData>} output: the two-dimensional
   *   array of data to write.
   */
  static appendOutputToRange(sheetName, rangeStartCol, output) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(sheetName);

    const lastRow = sheet.getLastRow() + 1;

    sheet
      .getRange(lastRow, rangeStartCol, output.length, output[0].length)
      .setValues(output);
    SpreadsheetApp.flush();
  }

  /**
   * Clears all entity data in the specified sheet.
   *
   * @param {!SheetConfig} sheetConfig for the spreadsheet to clean
   */
  static clearData(sheetConfig) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(sheetConfig.name);

    sheet
      .getRange(
        sheetConfig.rangeStartRow,
        sheetConfig.rangeStartCol,
        sheet.getLastRow(),
        sheet.getLastColumn()
      )
      .clearContent();
  }

  /**
   * Returns the row data for the given sheet and range as a two-dimensional
   * Array of length 1.
   *
   * @param {string} sheetName: the name of the sheet.
   * @param {number} rangeRow: the row index of data to return.
   * @param {number} rangeStartCol: the first column index of data to return.
   * @return {?Array&lt;!Array&lt;string>>} the two-dimensional
   *   of length 1 representing the row data.
   */
  static getRowData(sheetName, rangeRow, rangeStartCol) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(sheetName);
    const lastCol = sheet.getLastColumn();
    return sheet.getRange(rangeRow, rangeStartCol, 1, lastCol).getValues();
  }

  /**
   * Returns values in header row of selected sheet
   * as a 1-dim Array.
   * @param {!SheetConfig} sheetConfig of selected sheet
   * @return {!Array&lt;!RowData>} array names from header row of the sheet
   */
  static getHeaderRowData(sheetConfig) {
    return this.getRowData(sheetConfig.name, sheetConfig.headerRow, 1)[0];
  }

  /**
   * Retrieves value of input cell configured in configuration.js
   *
   * @param {!SheetConfig} sheetConfig of selected sheet
   * @return {string} input values
   */
  static getInputCellValues(sheetConfig) {
    const inputValues = {};
    for (const [name, cellId] of Object.entries(sheetConfig['inputCells'])) {
      const value = SheetUtil.getCellValue_(sheetConfig['name'], cellId);
      inputValues[name] = value;
    }
    return inputValues;
  }

  /**
   * Reads all rows of a sheet designated by sheetConfig
   * and returns cell values as {!Array&lt;!RowData>}
   * @param {!SheetConfig} sheetConfig
   * @return {!Array&lt;string>}
   */
  static readDataRows(sheetConfig) {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(
      sheetConfig.name
    );
    const headerRow = this.getHeaderRowData(sheetConfig);
    const rowCount = sheet.getLastRow() - sheetConfig.rangeStartRow + 1;
    const columnCount = headerRow.length - sheetConfig.rangeStartCol + 1;
    if (rowCount &lt; 1 || columnCount &lt; 1) {
      return [];
    }
    const data = sheet
      .getRange(
        sheetConfig.rangeStartRow,
        sheetConfig.rangeStartCol,
        rowCount,
        columnCount
      )
      .getValues();
    return data;
  }

  /**
   * Returns currently selected row (number) for chosen sheet.
   * Throws error if currently selected row isn't in data part of the sheet,
   * or if
   * @param {!SheetConfig} sheetConfig to look into
   * @return {number } row number that's currently selected
   */
  static getCurrentlySelectedDataRowNumber(sheetConfig) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(sheetConfig.name);
    const rowNumber = sheet.getActiveCell().getRowIndex();
    if (rowNumber &lt; sheetConfig.rangeStartRow) {
      throw new Error(
        `Selected cell in sheet ${sheetConfig.name}` + 'is not in data range'
      );
    }
    return rowNumber;
  }

  /**
   * Removes row from the sheet by sheet name and number
   * @param {!SheetConfig} sheetConfig
   * @param {!Array&lt;number>} rowNumbers
   */
  static deleteSheetRows(sheetConfig, rowNumbers) {
    const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = spreadsheet.getSheetByName(sheetConfig.name);

    const reindexedRows = rowNumbers.map((number, index) => number - index);
    reindexedRows.forEach(number => sheet.deleteRow(number));
  }
}</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="d6-csgIuVPoz0iQyrNS2Y"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="CellTranslator.html">CellTranslator</a></div><div class="sidebar-section-children"><a href="DateTranslator.html">DateTranslator</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="32ymzV-AR19hzjIAHjev2"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#addCustomProperty">addCustomProperty</a></div><div class="sidebar-section-children"><a href="global.html#cacheUrlFetchApp">cacheUrlFetchApp</a></div><div class="sidebar-section-children"><a href="global.html#cardinalToOrdinal">cardinalToOrdinal</a></div><div class="sidebar-section-children"><a href="global.html#createTree">createTree</a></div><div class="sidebar-section-children"><a href="global.html#cropCols">cropCols</a></div><div class="sidebar-section-children"><a href="global.html#cropRows">cropRows</a></div><div class="sidebar-section-children"><a href="global.html#cropSheet">cropSheet</a></div><div class="sidebar-section-children"><a href="global.html#daysSince">daysSince</a></div><div class="sidebar-section-children"><a href="global.html#driveWrite">driveWrite</a></div><div class="sidebar-section-children"><a href="global.html#ensure2dArray">ensure2dArray</a></div><div class="sidebar-section-children"><a href="global.html#getAllFoldersInFolder">getAllFoldersInFolder</a></div><div class="sidebar-section-children"><a href="global.html#getAllInFolder">getAllInFolder</a></div><div class="sidebar-section-children"><a href="global.html#getDatetimeCol">getDatetimeCol</a></div><div class="sidebar-section-children"><a href="global.html#getFilesAndFoldersInFolder">getFilesAndFoldersInFolder</a></div><div class="sidebar-section-children"><a href="global.html#getFolderByName">getFolderByName</a></div><div class="sidebar-section-children"><a href="global.html#getFolderContents">getFolderContents</a></div><div class="sidebar-section-children"><a href="global.html#onEdit">onEdit</a></div><div class="sidebar-section-children"><a href="global.html#prepareSheet">prepareSheet</a></div><div class="sidebar-section-children"><a href="global.html#readDrive">readDrive</a></div><div class="sidebar-section-children"><a href="global.html#removeDuplicateRows">removeDuplicateRows</a></div><div class="sidebar-section-children"><a href="global.html#timestamp">timestamp</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>